# -*- coding: utf-8 -*-
"""Practica0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1J0J7CDi3mfcaeL4VMINWa5CRn_Avqaxq

# Práctica 0 - Visión por Computador

Primero carguemos las librerías que usaremos para todos los ejercicios.
"""

from matplotlib import pyplot as plt
import numpy as np
import cv2
import math

"""Ahora definimos una función auxiliar para saber si una imagen es monobanda (solo tiene un valor en cada píxel).

Jugando con que las imagenes son de tipo numpy.array las imagenes monobanda serán o bien una matriz o una matriz de arrays de tamaño 1.
"""

# Devuelve si la imagen "img" es monobanda si solo tiene un canal (un único valor)
def es_monobanda(img):
  return len(img.shape) == 2 or (len(img.shape) == 3 and img.shape[2] == 1)

"""Para Colab tenemos que montar antes Google Drive para poder acceder a las imagenes de prueba."""

# Montamos los archivos de GoogleDrive
from google.colab import drive
drive.mount('/content/drive')

"""## Ejercicio 1

Se nos pide que carguemos una imagen de una ruta con un modo (gris, color, tal cual) la devolvamos y también imprimamos por pantalla la imagen en color y en gris.

Las imágenes de color en cv se guardan con el orden BGR por lo que para imprimir con matplot (que lee en RGB y usaremos para conseguir compatibilidad con el cuaderno de colab) hay que hacer una transformación antes, para ello usaremos `cvtColor`.
"""

# Devuelve una imagen con ruta "ruta" y modo "flag_color" y la imprime con color y gris
def lee_imagen(ruta, flag_color):
  # Cargamos la imagen
  img = cv2.imread(ruta, flag_color)
  # Por defecto (grises) se cargan todas igual
  img_RGB = img_gray = img
  # Imagen leída con color
  if flag_color == cv2.IMREAD_COLOR:
    img_RGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
  # Mostramos las imagenes en color y en gris
  # "gray" solo afecta si es monobanda
  plt.imshow(img_RGB, "gray")
  plt.show()
  plt.imshow(img_gray, "gray")
  plt.show()
  # Devolvemos la imagen cargada
  return img

"""Probemos cargando las 4 imágenes de prueba que se nos daban."""

img1 = lee_imagen("/content/drive/My Drive/Colab Notebooks/images/dave.jpg", cv2.IMREAD_GRAYSCALE)
img2 = lee_imagen("/content/drive/My Drive/Colab Notebooks/images/logoOpenCV.jpg", cv2.IMREAD_COLOR)
img3 = lee_imagen("/content/drive/My Drive/Colab Notebooks/images/messi.jpg", cv2.IMREAD_GRAYSCALE)
img4 = lee_imagen("/content/drive/My Drive/Colab Notebooks/images/orapple.jpg", cv2.IMREAD_COLOR)

"""## Ejercicio 2

En este ejercicio debemos tomar la matriz de una imagen, ya sea monobanda o tribanda, y normalizar los valores de cada banda; esto es tomar el valor mínimo y máximo de cada banda y convertir todos los valores de esa banda en la matriz al [0,1] correspondiendo el mínimo con el 0 y el máximo con el 1.

Aplicaremos la fórmula z = (x - min) / (max - min).
"""

# Toma la matriz de img, la normaliza y la imprime
def pintaI(img):
  # Copiamos la matriz como flotantes
  matriz = img.astype("float64")
  # Si la imagen es monobanda hacemos reshape para mayor comodidad
  if es_monobanda(matriz):
    matriz.shape = (matriz.shape[0], matriz.shape[1], 1)
  # Normalizamos por cada banda
  for i in range(matriz.shape[2]):
    # Cogemos la banda i-ésima
    banda_color = matriz[:, :, i]
    # Buscamos max y min
    v_max = np.amax(banda_color)
    v_min = np.amin(banda_color)
    diff = v_max - v_min
    # Si v_max > v_min podemos normalizar (si no es que todos tienen el mismo valor)
    if diff > 0:
      # Normalizamos
      banda_color[:, :] = (banda_color[:, :] - v_min) / diff
  # Deshacemos el reshape para las monobandas
  if es_monobanda(matriz):
    matriz.shape = (matriz.shape[0], matriz.shape[1])
  # Imprimimos la matriz
  print("Matriz normalizada: ")
  print(matriz)
  print("\n")

"""Veamos los 4 ejemplos ejecutados."""

pintaI(img1)
pintaI(img2)
pintaI(img3)
pintaI(img4)

"""## Ejercicio 3

Se nos pide que imprimamos varias imágenes a la vez, para ello usaremos la función `hconcat`, pero para ello necesitamos que las dimensiones de las imágenes concuerden lo que nos lleva a que todas las imágenes deben tener el mismo nº de bandas y de tamaño. 

En este caso hacemos que las en escala gris se pasen a tribanda (que mantienen la imagen) y así dejamos las RGB también iguales; y para el tamaño cogeremos la menor altura y anchura de todas y haremos `resize`.
"""

# Imprime varias imagenes juntas
def pintaMI(imgs):
  # Calulamos el mínimo de altura y anchura
  h_min = min([imgs[i].shape[0] for i in range(len(imgs))])
  w_min = min([imgs[i].shape[1] for i in range(len(imgs))])
  # Hacemos un cambio de dimensiones
  n_imgs = [cv2.resize(imgs[i], (w_min, h_min)) for i in range(len(imgs))]
  # Convertimos los grises en tribanda y los BGR en RGB
  for i in range(len(n_imgs)):
    if es_monobanda(n_imgs[i]):
      n_imgs[i] = cv2.cvtColor(n_imgs[i], cv2.COLOR_GRAY2RGB)
    else:
      n_imgs[i] = cv2.cvtColor(n_imgs[i], cv2.COLOR_BGR2RGB)
  # Juntamos todo e imprimimos
  img_compuesta = cv2.hconcat(n_imgs)
  plt.imshow(img_compuesta)
  plt.show()

"""Probemos."""

imagenes = [img1, img2, img3, img4]
pintaMI(imagenes)

"""## Ejercicio 4

Tenemos que hacer una función que dada una lista de coordenadas tipo `(x,y)` se modifique el color de cada píxel en esas coordenadas. Por ejemplo podemos poner a 255 la primera banda, lo que hará que en escala de grises esos píxeles se vean blancos, y en RGB se vean azules (en color está como BGR de ahí el azul).
"""

# Toma una imagen y una lista de coordenadas de píxeles y muestra la imagen
# modificada en esos píxeles (pone a blanco en escala grises y a azul en RGB)
def cambia_color(img, lista_coord):
  # Hacemos una copia para no modificar el original
  img_nueva = np.copy(img)
  # Si es monobanda hacemos reshape
  if es_monobanda(img_nueva):
    img_nueva.shape = (img_nueva.shape[0], img_nueva.shape[1], 1)
  # Por cada coord de pixel (x,y) modificamos el pixel(y,x) a 255
  for pixel in lista_coord:
    img_nueva[pixel[1], pixel[0], 0] = 255
  # Imprimimos la imagen segun toque el modo
  if es_monobanda(img_nueva):
    img_nueva.shape = (img_nueva.shape[0], img_nueva.shape[1])
  else:
    img_nueva = cv2.cvtColor(img_nueva, cv2.COLOR_BGR2RGB)
  plt.imshow(img_nueva, "gray")
  plt.show()

"""Probemos con una en grises y otra en color, fijamos la coordenada x (fijamos una columna) y la cambiamos entera."""

lista_coord = [(200, y) for y in range(img1.shape[0])]
cambia_color(img1, lista_coord)
lista_coord = [(200, y) for y in range(img2.shape[0])]
cambia_color(img2, lista_coord)

"""## Ejercicio 5

Finalmente tenemos que representar en una misma ventana varias imagenes con sus títulos. Para ello usaremos la función `subplot` para ponerlas todas en el mismo paquete y con sus títulos, en este caso no necesitamos que las imágenes sean iguales en cuanto a dimensión.
"""

# Imprime en una misma ventana (subplot) las imagenes con sus títulos
def pintaMI_ventana(imgs, titles):
  # Calculamos el tamaño de la matriz del subplot
  n = len(imgs)
  rows = cols = math.ceil(n ** (1/2)) 
  # Creamos el subplot con cada imagen
  for i in range(n):
    plt.subplot(rows, cols, i + 1)
    img = imgs[i]
    if not es_monobanda(imgs[i]):
      img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    plt.imshow(img, "gray")
    plt.title(titles[i])
    plt.xticks([])
    plt.yticks([])
  # Imprimimos por pantalla
  plt.show()

"""Probemos."""

titulos = ["Sudoku", "OpenCV", "Messi", "Manzana"]
pintaMI_ventana(imagenes, titulos)